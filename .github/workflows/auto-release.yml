name: Auto Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_bump:
        description: 'Force version bump type (major, minor, patch, or auto)'
        required: false
        default: 'auto'

env:
  CARGO_TERM_COLOR: always

jobs:
  analyze-and-release:
    name: Analyze Changes and Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for analysis
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Get current version
        id: current_version
        run: |
          version=$(grep '^version = ' Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "Current version: $version"

      - name: Get last release tag
        id: last_tag
        run: |
          last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "tag=$last_tag" >> $GITHUB_OUTPUT
          echo "Last release tag: $last_tag"

      - name: Analyze commits since last release
        id: analyze
        run: |
          # Get commits since last tag
          if [ "${{ steps.last_tag.outputs.tag }}" = "v0.0.0" ]; then
            commits=$(git log --pretty=format:"%s" HEAD)
          else
            commits=$(git log --pretty=format:"%s" ${{ steps.last_tag.outputs.tag }}..HEAD)
          fi
          
          echo "Commits since last release:"
          echo "$commits"
          echo ""
          
          # Analyze commit messages for conventional commits
          has_breaking=false
          has_feat=false
          has_fix=false
          
          while IFS= read -r commit; do
            # Check for breaking changes
            if echo "$commit" | grep -qiE '^[a-z]+(\([a-z]+\))?!:|BREAKING CHANGE:'; then
              has_breaking=true
              echo "Found breaking change: $commit"
            fi
            
            # Check for features
            if echo "$commit" | grep -qiE '^feat(\([a-z]+\))?:'; then
              has_feat=true
              echo "Found feature: $commit"
            fi
            
            # Check for fixes
            if echo "$commit" | grep -qiE '^fix(\([a-z]+\))?:'; then
              has_fix=true
              echo "Found fix: $commit"
            fi
          done <<< "$commits"
          
          # Determine bump type
          bump_type="none"
          if [ "$has_breaking" = true ]; then
            bump_type="major"
          elif [ "$has_feat" = true ]; then
            bump_type="minor"
          elif [ "$has_fix" = true ]; then
            bump_type="patch"
          fi
          
          # Override with manual input if provided
          if [ "${{ github.event.inputs.force_bump }}" != "" ] && [ "${{ github.event.inputs.force_bump }}" != "auto" ]; then
            bump_type="${{ github.event.inputs.force_bump }}"
            echo "Manual override: $bump_type"
          fi
          
          echo "bump_type=$bump_type" >> $GITHUB_OUTPUT
          echo "Determined bump type: $bump_type"

      - name: Calculate new version
        id: new_version
        if: steps.analyze.outputs.bump_type != 'none'
        run: |
          current="${{ steps.current_version.outputs.version }}"
          bump_type="${{ steps.analyze.outputs.bump_type }}"
          
          # Parse version
          IFS='.' read -r major minor patch <<< "$current"
          
          # Bump version
          case $bump_type in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac
          
          new_version="${major}.${minor}.${patch}"
          echo "version=$new_version" >> $GITHUB_OUTPUT
          echo "New version: $new_version"

      - name: Generate changelog
        id: changelog
        if: steps.analyze.outputs.bump_type != 'none'
        run: |
          # Get commits since last tag
          if [ "${{ steps.last_tag.outputs.tag }}" = "v0.0.0" ]; then
            commits=$(git log --pretty=format:"%s|%h|%an" HEAD)
          else
            commits=$(git log --pretty=format:"%s|%h|%an" ${{ steps.last_tag.outputs.tag }}..HEAD)
          fi
          
          # Categorize commits
          breaking_changes=""
          features=""
          fixes=""
          other=""
          
          while IFS='|' read -r message hash author; do
            # Breaking changes
            if echo "$message" | grep -qiE '^[a-z]+(\([a-z]+\))?!:|BREAKING CHANGE:'; then
              breaking_changes="${breaking_changes}- ${message} (${hash})\n"
            # Features
            elif echo "$message" | grep -qiE '^feat(\([a-z]+\))?:'; then
              clean_msg=$(echo "$message" | sed 's/^feat[^:]*: //')
              features="${features}- ${clean_msg} (${hash})\n"
            # Fixes
            elif echo "$message" | grep -qiE '^fix(\([a-z]+\))?:'; then
              clean_msg=$(echo "$message" | sed 's/^fix[^:]*: //')
              fixes="${fixes}- ${clean_msg} (${hash})\n"
            # Other
            else
              other="${other}- ${message} (${hash})\n"
            fi
          done <<< "$commits"
          
          # Build changelog
          changelog="## What's Changed\n\n"
          
          if [ -n "$breaking_changes" ]; then
            changelog="${changelog}### âš ï¸ Breaking Changes\n\n${breaking_changes}\n"
          fi
          
          if [ -n "$features" ]; then
            changelog="${changelog}### âœ¨ Features\n\n${features}\n"
          fi
          
          if [ -n "$fixes" ]; then
            changelog="${changelog}### ðŸ› Bug Fixes\n\n${fixes}\n"
          fi
          
          if [ -n "$other" ]; then
            changelog="${changelog}### ðŸ”§ Other Changes\n\n${other}\n"
          fi
          
          # Save to file for multiline output
          echo -e "$changelog" > /tmp/changelog.md
          echo "Generated changelog:"
          cat /tmp/changelog.md

      - name: Update version in files
        if: steps.analyze.outputs.bump_type != 'none'
        run: |
          new_version="${{ steps.new_version.outputs.version }}"
          
          # Update workspace Cargo.toml
          sed -i "s/^version = \".*\"/version = \"${new_version}\"/" Cargo.toml
          
          # Update all crate Cargo.toml files
          for cargo_file in crates/*/Cargo.toml; do
            sed -i "s/^version = \".*\"/version = \"${new_version}\"/" "$cargo_file"
            sed -i "s/omni-core = { version = \".*\"/omni-core = { version = \"${new_version}\"/" "$cargo_file"
          done
          
          # Update Cargo.lock
          cargo update --workspace --quiet

      - name: Update CHANGELOG.md
        if: steps.analyze.outputs.bump_type != 'none'
        run: |
          new_version="${{ steps.new_version.outputs.version }}"
          date=$(date +%Y-%m-%d)
          
          # Read generated changelog
          changelog=$(cat /tmp/changelog.md)
          
          # Create new CHANGELOG.md if it doesn't exist
          if [ ! -f CHANGELOG.md ]; then
            cat > CHANGELOG.md <<EOF
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [${new_version}] - ${date}

${changelog}
EOF
          else
            # Insert new version section after header
            awk -v version="$new_version" -v date="$date" -v changelog="$changelog" '
              /^# Changelog/ {
                print
                print ""
                print "## [" version "] - " date
                print ""
                print changelog
                next
              }
              /^## \[Unreleased\]/ {
                print
                print ""
                print "## [" version "] - " date
                print ""
                print changelog
                next
              }
              { print }
            ' CHANGELOG.md > CHANGELOG.md.tmp
            mv CHANGELOG.md.tmp CHANGELOG.md
          fi

      - name: Commit and tag
        if: steps.analyze.outputs.bump_type != 'none'
        run: |
          new_version="${{ steps.new_version.outputs.version }}"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add Cargo.toml Cargo.lock crates/*/Cargo.toml CHANGELOG.md
          git commit -m "chore(release): bump version to ${new_version}

[skip ci]"
          
          git tag -a "v${new_version}" -m "Release v${new_version}"
          
          git push origin main
          git push origin "v${new_version}"

      - name: Create GitHub Release
        if: steps.analyze.outputs.bump_type != 'none'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.new_version.outputs.version }}
          name: OmniContext v${{ steps.new_version.outputs.version }}
          body_path: /tmp/changelog.md
          draft: false
          prerelease: false
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: No release needed
        if: steps.analyze.outputs.bump_type == 'none'
        run: |
          echo "No version bump needed - no conventional commits found since last release"
          echo "Use conventional commit format:"
          echo "  feat: for new features (minor bump)"
          echo "  fix: for bug fixes (patch bump)"
          echo "  feat!: or BREAKING CHANGE: for breaking changes (major bump)"
