name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_bump:
        description: "Force version bump (major, minor, patch, or auto)"
        required: false
        default: "auto"

env:
  CARGO_TERM_COLOR: always

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Step 1: Analyze commits and determine if we should release
  analyze:
    name: Analyze Changes
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      bump_type: ${{ steps.check.outputs.bump_type }}
      new_version: ${{ steps.version.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get versions
        id: versions
        run: |
          current=$(grep '^version = ' Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
          last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "current=$current" >> $GITHUB_OUTPUT
          echo "last_tag=$last_tag" >> $GITHUB_OUTPUT

      - name: Analyze commits
        id: check
        run: |
          # Get commits since last tag
          if [ "${{ steps.versions.outputs.last_tag }}" = "v0.0.0" ]; then
            commits=$(git log --pretty=format:"%s" HEAD)
          else
            commits=$(git log --pretty=format:"%s" ${{ steps.versions.outputs.last_tag }}..HEAD)
          fi

          # Check for conventional commits
          has_breaking=false
          has_feat=false
          has_fix=false

          while IFS= read -r commit; do
            if echo "$commit" | grep -qiE '^[a-z]+(\([a-z]+\))?!:|BREAKING CHANGE:'; then
              has_breaking=true
            elif echo "$commit" | grep -qiE '^feat(\([a-z]+\))?:'; then
              has_feat=true
            elif echo "$commit" | grep -qiE '^fix(\([a-z]+\))?:'; then
              has_fix=true
            fi
          done <<< "$commits"

          # Determine bump type
          bump_type="none"
          if [ "$has_breaking" = true ]; then
            bump_type="major"
          elif [ "$has_feat" = true ]; then
            bump_type="minor"
          elif [ "$has_fix" = true ]; then
            bump_type="patch"
          fi

          # Override with manual input
          if [ "${{ github.event.inputs.force_bump }}" != "" ] && [ "${{ github.event.inputs.force_bump }}" != "auto" ]; then
            bump_type="${{ github.event.inputs.force_bump }}"
          fi

          should_release="false"
          if [ "$bump_type" != "none" ]; then
            should_release="true"
          fi

          echo "bump_type=$bump_type" >> $GITHUB_OUTPUT
          echo "should_release=$should_release" >> $GITHUB_OUTPUT
          echo "Bump type: $bump_type"
          echo "Should release: $should_release"

      - name: Calculate new version
        id: version
        if: steps.check.outputs.should_release == 'true'
        run: |
          current="${{ steps.versions.outputs.current }}"
          bump_type="${{ steps.check.outputs.bump_type }}"

          IFS='.' read -r major minor patch <<< "$current"

          case $bump_type in
            major) major=$((major + 1)); minor=0; patch=0 ;;
            minor) minor=$((minor + 1)); patch=0 ;;
            patch) patch=$((patch + 1)) ;;
          esac

          new_version="${major}.${minor}.${patch}"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT
          echo "New version: $new_version"

  # Step 2: Bump version and create release
  bump-and-tag:
    name: Bump Version and Tag
    needs: analyze
    if: needs.analyze.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ needs.analyze.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: dtolnay/rust-toolchain@stable

      - name: Update version files
        run: |
          new_version="${{ needs.analyze.outputs.new_version }}"

          # Update all Cargo.toml files
          sed -i "s/^version = \".*\"/version = \"${new_version}\"/" Cargo.toml
          for f in crates/*/Cargo.toml; do
            sed -i "s/^version = \".*\"/version = \"${new_version}\"/" "$f"
            sed -i "s/omni-core = { version = \".*\"/omni-core = { version = \"${new_version}\"/" "$f"
          done

          # Update package.json
          if [ -f editors/vscode/package.json ]; then
            sed -i "s/\"version\": \".*\"/\"version\": \"${new_version}\"/" editors/vscode/package.json
          fi

          cargo update --workspace --quiet

      - name: Generate changelog
        run: |
          last_tag="${{ needs.analyze.outputs.last_tag }}"
          if [ "$last_tag" = "v0.0.0" ]; then
            commits=$(git log --pretty=format:"%s|%h" HEAD)
          else
            commits=$(git log --pretty=format:"%s|%h" ${last_tag}..HEAD)
          fi

          changelog="## What's Changed\n\n"
          breaking=""; features=""; fixes=""; other=""

          while IFS='|' read -r msg hash; do
            if echo "$msg" | grep -qiE '^[a-z]+!:|BREAKING CHANGE:'; then
              breaking="${breaking}- ${msg} (${hash})\n"
            elif echo "$msg" | grep -qiE '^feat:'; then
              clean=$(echo "$msg" | sed 's/^feat[^:]*: //')
              features="${features}- ${clean} (${hash})\n"
            elif echo "$msg" | grep -qiE '^fix:'; then
              clean=$(echo "$msg" | sed 's/^fix[^:]*: //')
              fixes="${fixes}- ${clean} (${hash})\n"
            else
              other="${other}- ${msg} (${hash})\n"
            fi
          done <<< "$commits"

          [ -n "$breaking" ] && changelog="${changelog}### âš ï¸ Breaking Changes\n\n${breaking}\n"
          [ -n "$features" ] && changelog="${changelog}### âœ¨ Features\n\n${features}\n"
          [ -n "$fixes" ] && changelog="${changelog}### ðŸ› Bug Fixes\n\n${fixes}\n"
          [ -n "$other" ] && changelog="${changelog}### ðŸ”§ Other Changes\n\n${other}\n"

          echo -e "$changelog" > /tmp/changelog.md

      - name: Update CHANGELOG.md
        run: |
          new_version="${{ needs.analyze.outputs.new_version }}"
          date=$(date +%Y-%m-%d)
          changelog=$(cat /tmp/changelog.md)

          if [ ! -f CHANGELOG.md ]; then
            echo "# Changelog" > CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "## [${new_version}] - ${date}" >> CHANGELOG.md
            echo "" >> CHANGELOG.md
            cat /tmp/changelog.md >> CHANGELOG.md
          else
            awk -v version="$new_version" -v date="$date" -v changelog="$(cat /tmp/changelog.md)" '
              /^# Changelog/ { print; print ""; print "## [" version "] - " date; print ""; print changelog; next }
              { print }
            ' CHANGELOG.md > CHANGELOG.md.tmp
            mv CHANGELOG.md.tmp CHANGELOG.md
          fi

      - name: Commit and push
        run: |
          new_version="${{ needs.analyze.outputs.new_version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add Cargo.toml Cargo.lock crates/*/Cargo.toml editors/vscode/package.json CHANGELOG.md
          git commit -m "chore(release): bump version to ${new_version} [skip ci]"
          git tag -a "v${new_version}" -m "Release v${new_version}"

          git push origin main
          git push origin "v${new_version}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.analyze.outputs.new_version }}
          name: OmniContext v${{ needs.analyze.outputs.new_version }}
          body_path: /tmp/changelog.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Step 3: Build binaries for all platforms
  build:
    name: Build ${{ matrix.target }}
    needs: bump-and-tag
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            ext: zip
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            ext: tar.gz
          - os: macos-latest
            target: x86_64-apple-darwin
            ext: tar.gz
          - os: macos-latest
            target: aarch64-apple-darwin
            ext: tar.gz
    steps:
      - uses: actions/checkout@v4
        with:
          ref: v${{ needs.bump-and-tag.outputs.version }}

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - uses: Swatinem/rust-cache@v2

      - name: Build
        run: cargo build --release --target ${{ matrix.target }} --workspace --bins

      - name: Create archive (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $version = "${{ needs.bump-and-tag.outputs.version }}"
          $target = "${{ matrix.target }}"
          $archive = "omnicontext-${version}-${target}.zip"

          New-Item -ItemType Directory -Path staging -Force
          Copy-Item "target/${{ matrix.target }}/release/omnicontext.exe" staging/
          Copy-Item "target/${{ matrix.target }}/release/omnicontext-mcp.exe" staging/
          Copy-Item "target/${{ matrix.target }}/release/omnicontext-daemon.exe" staging/
          Copy-Item README.md, LICENSE, INSTALL.md staging/

          Compress-Archive -Path staging/* -DestinationPath $archive
          $hash = (Get-FileHash -Algorithm SHA256 $archive).Hash
          "$hash  $archive" | Out-File -FilePath "${archive}.sha256" -Encoding ASCII

          echo "ARCHIVE=$archive" >> $env:GITHUB_ENV

      - name: Create archive (Unix)
        if: matrix.os != 'windows-latest'
        run: |
          version="${{ needs.bump-and-tag.outputs.version }}"
          target="${{ matrix.target }}"
          archive="omnicontext-${version}-${target}.tar.gz"

          mkdir -p staging
          cp "target/${{ matrix.target }}/release/omnicontext" staging/
          cp "target/${{ matrix.target }}/release/omnicontext-mcp" staging/
          cp "target/${{ matrix.target }}/release/omnicontext-daemon" staging/ || true
          cp README.md LICENSE INSTALL.md staging/

          tar -czf "$archive" -C staging .

          if [[ "$OSTYPE" == "darwin"* ]]; then
            shasum -a 256 "$archive" > "${archive}.sha256"
          else
            sha256sum "$archive" > "${archive}.sha256"
          fi

          echo "ARCHIVE=$archive" >> $GITHUB_ENV

      - name: Upload to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.bump-and-tag.outputs.version }}
          files: |
            ${{ env.ARCHIVE }}
            ${{ env.ARCHIVE }}.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Step 4: Publish VS Code Extension
  publish-extension:
    name: Publish VS Code Extension
    needs: bump-and-tag
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: v${{ needs.bump-and-tag.outputs.version }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1

      - name: Install dependencies
        working-directory: editors/vscode
        run: bun install

      - name: Compile
        working-directory: editors/vscode
        run: bun run compile

      - name: Publish to Marketplace
        working-directory: editors/vscode
        run: npx vsce publish -p ${{ secrets.VSCE_PAT }} --no-dependencies
        if: github.repository == 'steeltroops-ai/omnicontext' && env.VSCE_PAT != ''
        env:
          VSCE_PAT: ${{ secrets.VSCE_PAT }}

      - name: Publish to Open VSX
        working-directory: editors/vscode
        run: npx ovsx publish -p ${{ secrets.OVSX_PAT }} --no-dependencies
        if: github.repository == 'steeltroops-ai/omnicontext' && env.OVSX_PAT != ''
        env:
          OVSX_PAT: ${{ secrets.OVSX_PAT }}
